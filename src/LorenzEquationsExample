import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
import pysindy as ps

# Lorenz system
def lorenz(t, xyz, sigma=10, beta=8/3, rho=28):
    x, y, z = xyz
    dxdt = sigma * (y - x)
    dydt = x * (rho - z) - y
    dzdt = x * y - beta * z
    return [dxdt, dydt, dzdt]

# Simulate the actual system
t_span = (0, 25)
dt = 0.01
t_eval = np.arange(t_span[0], t_span[1], dt)
initial_condition = [1.0, 1.0, 1.0]
actual_solution = solve_ivp(lorenz, t_span, initial_condition, t_eval=t_eval)
x_actual = actual_solution.y.T

# Add noise
noise_strength = 0.5
x_noisy = x_actual + noise_strength * np.random.normal(size=x_actual.shape)

# Fit SINDy model
model = ps.SINDy()
model.fit(x_noisy, t=dt)
model.print()

# Simulate SINDy model
x_sindy = model.simulate(initial_condition, t_eval)

# Plot comparison of actual system vs SINDy model
fig = plt.figure(figsize=(12, 5))
ax1 = fig.add_subplot(121, projection='3d')
ax1.plot(*x_actual.T, color='blue', label='True')
ax1.set_title("Actual Lorenz System")
ax1.set_xlabel("x"); ax1.set_ylabel("y"); ax1.set_zlabel("z")

ax2 = fig.add_subplot(122, projection='3d')
ax2.plot(*x_sindy.T, color='orange', label='SINDy')
ax2.set_title("SINDy Model")
ax2.set_xlabel("x"); ax2.set_ylabel("y"); ax2.set_zlabel("z")

plt.tight_layout()
plt.show()

from sklearn.metrics import mean_squared_error

# Compute MSE per variable and total
mse_x = mean_squared_error(x_actual[:, 0], x_sindy[:, 0])
mse_y = mean_squared_error(x_actual[:, 1], x_sindy[:, 1])
mse_z = mean_squared_error(x_actual[:, 2], x_sindy[:, 2])
mse_total = mean_squared_error(x_actual, x_sindy)

# Print MSE results
print("\nMean Squared Error (MSE) between actual Lorenz system and SINDy model:")
print(f"  x: {mse_x:.4f}")
print(f"  y: {mse_y:.4f}")
print(f"  z: {mse_z:.4f}")
print(f"  Total (all variables): {mse_total:.4f}")
